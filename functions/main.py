import base64
import datetime

from fastapi import Request
from jinja2 import Environment, FileSystemLoader
from playwright.async_api import Page, ElementHandle

from constants import templates_path, elements_to_disable
from .browser import Browser
from .exceptions import ElementNotFound, RequiredURL
from .options import ScreenshotOptions, PageScreenshotOptions, ElementScreenshotOptions, SectionScreenshotOptions

env = Environment(loader=FileSystemLoader(templates_path), autoescape=True)

class WebRender:
    browser: Browser = None
    debug: bool = False
    custom_css = open(templates_path + '/custom.css', 'r', encoding='utf-8').read()

    def __init__(self, debug: bool = False):
        self.debug = debug

        if not WebRender.browser:
            self.browser = Browser(debug=debug)
            self.browser_init = self.browser.browser_init
            self.browser_close = self.browser.close
            self.logger = self.browser.logger


    @staticmethod
    async def select_element(el: str | list, pg: Page) -> (ElementHandle, str):
        if isinstance(el, str):
            return (await pg.query_selector(el)), el
        else:
            for obj in el:
                rtn = await pg.query_selector(obj)
                if rtn is not None:
                    return rtn, obj

    @staticmethod
    async def make_screenshot(page: Page, el: ElementHandle) -> list:
        await page.evaluate("window.scroll(0, 0)")
        await page.route('**/*', lambda route: route.abort())
        images = []
        img = await el.screenshot(type='png')
        images.append(base64.b64encode(img).decode())
        return images


    @staticmethod
    async def add_count_box(page: Page, element: str, start_time: float = datetime.datetime.now().timestamp()):
        return await page.evaluate("""
            ({selected_element, start_time}) => {
                t = document.createElement('span')
                t.className = 'bot-countbox'
                t.style = 'position: absolute;opacity: 0.2;'
                document.querySelector(selected_element).insertBefore(t, document.querySelector(selected_element).firstChild)
                countTime();
                function countTime() {
                    var nowtime = new Date();
                    var lefttime = parseInt((nowtime.getTime() - start_time) / 1000);
                    document.querySelector(".bot-countbox").innerHTML = `Generated by akaribot in ${lefttime}s`;
                    if (lefttime <= 0) {
                        return;
                    }
                setTimeout(countTime, 1000);
                }
            }""", {'selected_element': element, 'start_time': int(start_time * 1000)})

    @classmethod
    async def legacy_screenshot(cls, options: ScreenshotOptions):
        start_time = datetime.datetime.now().timestamp()
        page = await cls.browser.new_page(width=options.width, height=options.height)
        rendered_html = env.get_template("content.html").render(language='zh-CN', content=options.content)
        await page.set_content(rendered_html, wait_until='networkidle')
        if options.mw:
            selector = 'body > .mw-parser-output > *:not(script):not(style):not(link):not(meta)'
        else:
            selector = 'body > *:not(script):not(style):not(link):not(meta)'
        element_ = await page.query_selector(selector)
        if not element_:
            raise ElementNotFound
        if options.counttime:
            await cls.add_count_box(page, selector, start_time)
        images = await cls.make_screenshot(page, element_)
        if not cls.debug:
            await page.close()
        return images

    @classmethod
    async def page_screenshot(cls, options: PageScreenshotOptions):
        page = await Browser.new_page()
        await page.goto(options.url, wait_until="networkidle")
        custom_css = cls.custom_css
        await page.add_style_tag(content=custom_css)
        if options.css:
            await page.add_style_tag(content=options.css)
        screenshot = await cls.make_screenshot(page, await page.query_selector("body"))
        if not cls.debug:
            await page.close()
        return screenshot

    @classmethod
    async def element_screenshot(cls, options: ElementScreenshotOptions):
        start_time = datetime.datetime.now().timestamp()
        page = await Browser.new_page(width=options.width, height=options.height)
        if options.content:
            await page.set_content(options.content)
        else:
            await page.goto(options.url, wait_until="networkidle")
        custom_css = cls.custom_css
        await page.add_style_tag(content=custom_css)
        if options.css:
            await page.add_style_tag(content=options.css)
        # :rina: :rina: :rina: :rina:
        await page.evaluate("""(elements_to_disable) => {
                const images = document.querySelectorAll("img")
                images.forEach(image => {
                  image.removeAttribute('loading');
                })
                const animated = document.querySelectorAll(".animated")
                for (var i = 0; i < animated.length; i++) {
                  b = animated[i].querySelectorAll('img')
                  for (ii = 0; ii < b.length; ii++) {
                    b[ii].width = b[ii].getAttribute('width') / (b.length / 2)
                    b[ii].height = b[ii].getAttribute('height') / (b.length / 2)
                  }
                  animated[i].className = 'nolongeranimatebaka'
                }
                for (var i = 0; i < elements_to_disable.length; i++) {
                  const element_to_boom = document.querySelector(elements_to_disable[i])// :rina: :rina: :rina: :rina:
                  if (element_to_boom != null) {
                    element_to_boom.style = 'display: none'
                  }
                }
                document.querySelectorAll('*').forEach(element => {
                  element.parentNode.replaceChild(element.cloneNode(true), element);
                });
                window.scroll(0, 0)
              }""", elements_to_disable)
        el, selected_ = await cls.select_element(options.element, page)
        if not el:
            raise ElementNotFound
        if options.counttime:
            await cls.add_count_box(page, selected_, start_time)
        images = await cls.make_screenshot(page, el)
        if not cls.debug:
            await page.close()
        return images

    @classmethod
    async def section_screenshot(cls, options: SectionScreenshotOptions):
        start_time = datetime.datetime.now().timestamp()
        page = await Browser.new_page(width=options.width, height=options.height)
        if options.content:
            await page.set_content(options.content)
        else:
            await page.goto(options.url, wait_until="networkidle")
        if options.css:
            await page.add_style_tag(content=options.css + cls.custom_css)
        section, selected_ = await cls.select_element(options.section, page)
        if not section:
            raise ElementNotFound
        if options.counttime:
            await cls.add_count_box(page, selected_, start_time)
        images = await cls.make_screenshot(page, section)
        if not cls.debug:
            await page.close()
        return images

    @classmethod
    async def source(cls, request: Request):
        page = await Browser.new_page()
        try:
            url = request.query_params.get("url")
            if not url:
                raise RequiredURL

            await page.goto(url, wait_until="networkidle")
            _source = await page.content()

            return _source
        finally:
            if not cls.debug:
                await page.close()